using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Http;
using System.Runtime.Caching;
using System.Threading.Tasks;
using System.Web.Http;
using AutoMapper;
using Fred.Business.CI;
using Fred.Business.Common.ExportDocument;
using Fred.Business.CompteExploitation.BilanTechnique;
using Fred.Business.CompteExploitation.Excel13C4C.Managers.Interfaces;
using Fred.Business.CompteExploitation.TableauSynthese.Interfaces;
using Fred.Business.Images;
using Fred.Business.Referential.Tache;
using Fred.Business.ReferentielFixe;
using Fred.Business.VerificationPointage;
using Fred.Entities.ReferentielFixe;
using Fred.Entities.VerificationPointage;
using Fred.Web.Models.Referential;
using Fred.Web.Models.ReferentielFixe;
using Fred.Web.Shared.Models.CompteExploitation;
using Fred.Web.Shared.Models.CompteExploitation.BilanTechnique;
using Fred.Web.Shared.Models.CompteExploitation.TableauSynthese;
using Fred.Web.Shared.Models.Rapport.Search;

namespace Fred.Web.API
{
    /// <summary>
    /// Représente une instance de contrôleur Web API pour le module CompteExploitation.
    /// <seealso cref="ApiController" />
    /// </summary>
    public class CompteExploitationController : ApiControllerBase
    {
        private const string ExcelCachePrefix = "excelBytes_";
        private const string FilePrefix = "CptExploit_";
        private const string PdfCachePrefix = "pdfBytes_";


        protected readonly IMapper mapper;
        protected readonly ITacheManager TacheMgr;
        protected readonly IReferentielFixeManager RefMgr;
        protected readonly IExportDocumentService ExportDocumentService;
        protected readonly ICIManager CIMgr;
        protected readonly IImageManager imageManager;
        private readonly IChekingPointingManager chekingPointingManager;
        private readonly ITableauSyntheseExportManager tableauSyntheseExportManager;
        private readonly IBilanTechniqueExportManager bilanTechniqueExportManager;
        private readonly ICompteExploitation4CManager compteExploitation4CManager;
        private readonly ICompteExploitation13CManager compteExploitation13CManager;

        /// <summary>
        /// Initialise une nouvelle instance de la classe <see cref="CommandeController"/>.
        /// </summary>
        /// <param name="cptExplMgr">Manageur des compte d'exploitation</param>
        /// <param name="mapper">Auto Mapper modèle / entité</param>
        /// <param name="tacheMgr">Manageur des tâches</param>
        /// <param name="refMgr">Manageur des Référentielx fixes</param>
        /// <param name="exportDocumentService">Manageur des Exports documentaires</param>
        /// <param name="ciMgr">Manageur des CIs</param>
        /// <param name="imageManager">Manageur des Images</param>
        public CompteExploitationController(
            IMapper mapper, ITacheManager tacheMgr,
            IReferentielFixeManager refMgr,
            IExportDocumentService exportDocumentService,
            ICIManager ciMgr,
            IImageManager imageManager,
            IChekingPointingManager chekingPointingManager,
            ITableauSyntheseExportManager tableauSyntheseExportManager,
            IBilanTechniqueExportManager bilanTechniqueExportManager,
            ICompteExploitation4CManager compteExploitation4CManager,
            ICompteExploitation13CManager compteExploitation13CManager)
        {
            this.mapper = mapper;
            this.TacheMgr = tacheMgr;
            this.RefMgr = refMgr;
            this.ExportDocumentService = exportDocumentService;
            this.CIMgr = ciMgr;
            this.imageManager = imageManager;
            this.chekingPointingManager = chekingPointingManager;
            this.tableauSyntheseExportManager = tableauSyntheseExportManager;
            this.bilanTechniqueExportManager = bilanTechniqueExportManager;
            this.compteExploitation4CManager = compteExploitation4CManager;
            this.compteExploitation13CManager = compteExploitation13CManager;
        }

        /// <summary>
        /// Active le téléchargement du fichier généré précemment
        /// </summary>
        /// <param name="cacheId">Id de stockage du cache</param>
        /// <param name="type">Type de fichier d'export PDF / Excel</param>
        /// <returns>Réponse du document créé</returns>
        [HttpGet]
        [Route("api/CompteExploitation/DownloadEdition/{type}/{cacheId}")]
        public HttpResponseMessage DownloadEdition(string cacheId, string type)
        {
            var isPdf = false;
            if (type.Equals("PDF"))
            {
                isPdf = true;
            }
            var cacheName = ExportDocumentService.GetCacheName(cacheId, isPdf);
            var bytes = MemoryCache.Default.Get(cacheName) as byte[];
            if (bytes != null)
            {
                MemoryCache.Default.Remove(cacheName);
            }
            var exportFilename = ExportDocumentService.GetDocumentFileName(FilePrefix + DateTime.Now.ToShortDateString(), isPdf);
            return ExportDocumentService.CreateResponseForDownloadDocument(exportFilename, bytes);
        }




        /// <summary>
        /// POST api/CompteExploitation/Edition
        /// </summary>
        /// <param name="format">Type d'export PDF / Excel</param>
        /// <param name="ciId">Identifiant du groupe du user</param>
        /// <param name="period">Période du compte d'exploitation</param>
        /// <param name="perimeter">Etat complet / filtré</param>
        /// <param name="analyticAxis">axes analytique (Tache>Ressource ou Ressource>Tache)</param>
        /// <param name="allAxis">Tous les axes regroupés (principal/secondaire) (T1,T2,T3) ou (Chapitre,SousChapitre,Ressource)</param>
        /// <param name="valFiltre">La valeur du filtre de périmètre si type T1/T2/Chap/Sous Chap</param>
        /// <param name="valFiltreLibelle">Code de la valeur du filtre de périmètre si type T1/T2/Chap/Sous Chap</param>
        /// <returns>Liste de chapitres</returns>
        [HttpPost]
        [Route("api/CompteExploitation/Edition13C/{format}/{ciId}/{period}/{perimeter}/{analyticAxis}/{allAxis}/{valFiltre?}/{valFiltreLibelle?}")]
#pragma warning disable S107 // Methods should not have too many parameters
        public async Task<IHttpActionResult> Edition13C(string format, int ciId, string period, string perimeter, string analyticAxis, string allAxis, int? valFiltre = 0, string valFiltreLibelle = "")
#pragma warning restore S107 // Methods should not have too many parameters
        {
            var generateExcel13CParameterModel = new GenerateExcel13CParameterModel()
            {
                Format = format,
                CiId = ciId,
                Period = period,
                Perimeter = perimeter,
                AnalyticAxis = analyticAxis,
                AllAxis = allAxis,
                ValFiltre = valFiltre,
                ValFiltreLibelle = valFiltreLibelle
            };

            byte[] bytes = await compteExploitation13CManager.GenerateExcel13CAsync(generateExcel13CParameterModel);


            string cacheId = Guid.NewGuid().ToString();

            CacheItemPolicy policy = new CacheItemPolicy
            {
                AbsoluteExpiration = DateTimeOffset.Now.AddSeconds(300),
                Priority = CacheItemPriority.NotRemovable
            };

            var goodCachePrefix = ExcelCachePrefix;
            if (format.Equals("PDF"))
            {
                goodCachePrefix = PdfCachePrefix;
            }
            MemoryCache.Default.Add(goodCachePrefix + cacheId, bytes, policy);

            return Ok(new { id = cacheId });

        }

        /// <summary>
        /// POST api/CompteExploitation/Edition
        /// </summary>
        /// <param name="format">Type d'export PDF / Excel</param>
        /// <param name="ciId">Identifiant du groupe du user</param>
        /// <param name="period">Période du compte d'exploitation</param>
        /// <param name="perimeter">Etat complet / filtré</param>
        /// <param name="analyticAxis">axes analytique (Tache>Ressource ou Ressource>Tache)</param>
        /// <param name="allAxis">Tous les axes regroupés (principal/secondaire) (T1,T2,T3) ou (Chapitre,SousChapitre,Ressource)</param>
        /// <param name="valFiltre">La valeur du filtre de périmètre si type T1/T2/Chap/Sous Chap</param>
        /// <param name="valFiltreLibelle">Code de la valeur du filtre de périmètre si type T1/T2/Chap/Sous Chap</param>
        /// <returns>Liste de chapitres</returns>
        [HttpPost]
        [Route("api/CompteExploitation/Edition4C/{format}/{ciId}/{period}/{perimeter}/{analyticAxis}/{allAxis}/{valFiltre?}/{valFiltreLibelle?}")]
#pragma warning disable S107 // Methods should not have too many parameters
        public async Task<IHttpActionResult> Edition4C(string format, int ciId, string period, string perimeter, string analyticAxis, string allAxis, int? valFiltre = 0, string valFiltreLibelle = "")
#pragma warning restore S107 // Methods should not have too many parameters
        {
            var generateExcel4CParameterModel = new GenerateExcel4CParameterModel()
            {
                Format = format,
                CiId = ciId,
                Period = period,
                Perimeter = perimeter,
                AnalyticAxis = analyticAxis,
                AllAxis = allAxis,
                ValFiltre = valFiltre,
                ValFiltreLibelle = valFiltreLibelle
            };

            byte[] bytes = await compteExploitation4CManager.GenerateExcel4CAsync(generateExcel4CParameterModel);

            string cacheId = Guid.NewGuid().ToString();

            CacheItemPolicy policy = new CacheItemPolicy
            {
                AbsoluteExpiration = DateTimeOffset.Now.AddSeconds(300),
                Priority = CacheItemPriority.NotRemovable
            };

            var goodCachePrefix = ExcelCachePrefix;
            if (format.Equals("PDF"))
            {
                goodCachePrefix = PdfCachePrefix;
            }
            MemoryCache.Default.Add(goodCachePrefix + cacheId, bytes, policy);

            return Ok(new { id = cacheId });

        }


        ///// <summary>
        /////  Envoi liste de pointages (Personnel/Machine)
        ///// </summary>
        ///// <param name="param">paramètres pour filtrer</param>
        ///// <returns>retouner le pointage pendant Mensuel (Personnel/Machine) </returns>
        [HttpPost]
        public object EtatVerifPointing([FromBody] FilterChekingPointingModel param)
        {
            try
            {
                byte[] excelBytes = chekingPointingManager.ChekingPointing(mapper.Map<FilterChekingPointing>(param));

                var policy = new CacheItemPolicy { AbsoluteExpiration = DateTimeOffset.Now.AddSeconds(30), Priority = CacheItemPriority.NotRemovable };
                string cacheId = Guid.NewGuid().ToString();
                MemoryCache.Default.Add("excelBytes_" + cacheId, excelBytes, policy);
                return new { id = cacheId };
            }
            catch (Exception ex)
            {
                return Request.CreateErrorResponse(HttpStatusCode.InternalServerError, ex);
            }
        }

        /// <summary>
        /// Active le téléchargement du fichier généré précemment
        /// </summary>
        /// <param name="cacheId">Id de stockage du cache</param>
        /// <returns>Réponse du document créé</returns>
        [HttpGet]
        [Route("api/CompteExploitation/ExportVerifPointing/{cacheId}")]
        public object ExportVerifPointing(string cacheId)
        {
            const bool isPdf = false;
            var cacheName = ExportDocumentService.GetCacheName(cacheId, isPdf);
            var bytes = MemoryCache.Default.Get(cacheName) as byte[];
            if (bytes != null)
            {
                MemoryCache.Default.Remove(cacheName);
            }
            var exportFilename = ExportDocumentService.GetDocumentFileName(FilePrefix + DateTime.Now.ToShortDateString(), isPdf);
            return ExportDocumentService.CreateResponseForDownloadDocument(exportFilename, bytes);
        }

        #region Bilan Technique

        [HttpPost]
        [Route("api/CompteExploitation/BilanExport")]
        public async Task<IHttpActionResult> CreateExportBilanTechniqueAsync(LoadBilanTechniqueExportModel model)
        {
            try
            {
                byte[] bytes = await bilanTechniqueExportManager.GetExportBilanTechniqueAsync(model).ConfigureAwait(false);
                if (bytes.Length == 0)
                {
                    return Ok(new { id = string.Empty });       // Indique qu'il n'y a pas de données
                }
                string typeCache = model.IsPdfConverted ? "pdfBytes_" : "excelBytes_";
                string cacheId = Guid.NewGuid().ToString();

                CacheItemPolicy policy = new CacheItemPolicy { AbsoluteExpiration = DateTimeOffset.Now.AddSeconds(300), Priority = CacheItemPriority.NotRemovable };
                MemoryCache.Default.Add(typeCache + cacheId, bytes, policy);

                return Ok(new { id = cacheId });
            }
            catch (Exception ex)
            {
                logger.Log(NLog.LogLevel.Error, ex);
                return null;                                // Indique qu'une exception s'est produite
            }

        }

        [HttpGet]
        [Route("api/CompteExploitation/BilanExport/{id}/{isPdf}")]
        public HttpResponseMessage GetExportBilanTechnique(string id, bool isPdf)
        {
            var cacheName = ExportDocumentService.GetCacheName(id, isPdf);
            var bytes = MemoryCache.Default.Get(cacheName) as byte[];
            if (bytes != null)
            {
                MemoryCache.Default.Remove(cacheName);
            }
            var exportFilename = ExportDocumentService.GetDocumentFileName("BilanTechnique", isPdf);
            return ExportDocumentService.CreateResponseForDownloadDocument(exportFilename, bytes);
        }

        #endregion //Bilan Technique

        /// <summary>
        /// GET api/CompteExploitation/GetChapitres
        /// </summary>
        /// <param name="groupId">Identifiant du groupe du user</param>
        /// <param name="page">page index</param>
        /// <param name="pageSize">windows page size</param>
        /// <param name="recherche">text</param>
        /// <returns>Liste de chapitres</returns>
        [HttpGet]
        [Route("api/CompteExploitation/GetChapitres/{groupId}/{page?}/{pageSize?}/{recherche?}/")]
        public HttpResponseMessage GetChapitres(int groupId, int page = 1, int pageSize = 20, string recherche = "")
        {
            IEnumerable<ChapitreEnt> listChapitre = this.RefMgr.SearchChapitres(recherche, groupId);

            var mapresult = this.mapper.Map<List<ChapitreModel>>(listChapitre);

            return Request.CreateResponse(HttpStatusCode.OK, mapresult);
        }

        /// <summary>
        /// GET api/CompteExploitation/GetSousChapitres
        /// </summary>
        /// <param name="groupId">Identifiant du groupe du user</param>
        /// <param name="page">page index</param>
        /// <param name="pageSize">windows page size</param>
        /// <param name="recherche">text</param>
        /// <returns>Liste de chapitres</returns>
        [HttpGet]
        [Route("api/CompteExploitation/GetSousChapitres/{groupId}/{page?}/{pageSize?}/{recherche?}/")]
        public HttpResponseMessage GetSousChapitres(int groupId, int page = 1, int pageSize = 20, string recherche = "")
        {
            IEnumerable<SousChapitreEnt> listSousChapitres = this.RefMgr.SearchSousChapitres(recherche, groupId);

            var mapresult = this.mapper.Map<List<SousChapitreModel>>(listSousChapitres);

            return Request.CreateResponse(HttpStatusCode.OK, mapresult);
        }

        ///// <summary>
        /////   GET Rechercher les tâches
        ///// </summary>
        ///// <param name="ci">Ci pour filtrer</param>
        ///// <param name="page">page index</param>
        ///// <param name="pageSize">windows page size</param>
        ///// <param name="recherche">text</param>
        ///// <returns>retouner une liste de CI</returns>
        [HttpGet]
        [Route("api/CompteExploitation/GetTaches/{ci}/{niveau}/{page?}/{pageSize?}/{recherche?}/")]
        public HttpResponseMessage GetTaches(int ci, int niveau, int page = 1, int pageSize = 20, string recherche = "")
        {
            return Get(() => mapper.Map<IEnumerable<TacheModel>>(this.TacheMgr.SearchLight(recherche, page, pageSize, ci, true, niveau)));
        }

        /// <summary>
        /// POST Géneration de l'export du Tableau de Synthese
        /// </summary>
        /// <param name="model">Model de génération en input</param>
        /// <returns>Id de cache pour telechargement</returns>
        [HttpPost]
        [Route("api/CompteExploitation/TableauSyntheseExport")]
        public async Task<IHttpActionResult> GetExportTableauSyntese(TableauSyntheseLoadExportModel model)
        {
            byte[] bytes = await tableauSyntheseExportManager.GetExportTableauSyntheseAsync(model);
            var policy = new CacheItemPolicy { AbsoluteExpiration = DateTimeOffset.Now.AddSeconds(30), Priority = CacheItemPriority.NotRemovable };
            var cacheId = Guid.NewGuid().ToString();

            if (model.IsPdfConverted)
            {
                MemoryCache.Default.Add("pdfBytes_" + cacheId, bytes, policy);
            }
            else
            {
                MemoryCache.Default.Add("excelBytes_" + cacheId, bytes, policy);
            }

            return Ok(new { id = cacheId });
        }

        /// <summary>
        /// GET Telechargement du fichier mis en cache
        /// </summary>
        /// <param name="id">Id de cache</param>
        /// <param name="filename">Nom de fichier</param>
        /// <param name="pdf">flag de conversion pdf</param>
        /// <returns>fichier sous forme de tableau d'octets</returns>
        [HttpGet]
        [Route("api/CompteExploitation/ExtractDocument/{id}/{filename}/{pdf}")]
        public HttpResponseMessage ExtractDocument(string id, string filename, bool pdf)
        {
            var cacheName = ExportDocumentService.GetCacheName(id, isPdf: pdf);
            var bytes = MemoryCache.Default.Get(cacheName) as byte[];
            if (bytes != null)
            {
                MemoryCache.Default.Remove(cacheName);
            }
            var exportDocument = ExportDocumentService.GetDocumentFileName(filename, pdf);
            var result = ExportDocumentService.CreateResponseForDownloadDocument(exportDocument, bytes);
            return result;
        }

    }
}
