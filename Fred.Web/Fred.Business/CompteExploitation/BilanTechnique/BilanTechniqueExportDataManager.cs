using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Fred.Business.Budget;
using Fred.Business.Budget.Avancement;
using Fred.Business.Budget.Helpers;
using Fred.Business.Budget.Mapper;
using Fred.Business.Depense;
using Fred.Business.Depense.Services;
using Fred.Business.ReferentielEtendu;
using Fred.DataAccess.Interfaces;
using Fred.Entities;
using Fred.Entities.Budget;
using Fred.Entities.Budget.Avancement;
using Fred.Framework.Exceptions;
using Fred.Web.Shared.Models.Budget.Depense;
using Fred.Web.Shared.Models.CompteExploitation.BilanTechnique;
using MoreLinq;

namespace Fred.Business.CompteExploitation.BilanTechnique
{
    public class BilanTechniqueExportDataManager : IBilanTechniqueExportDataManager
    {
        private readonly IAvancementManager avancementManager;
        private readonly IControleBudgetaireManager controleBudgetaireManager;
        private readonly IBudgetT4Manager budgetT4Manager;
        private readonly IReferentielEtenduManager referentielEtenduManager;
        private readonly IDepenseServiceMediator depenseServiceMediator;
        private readonly ICIRepository ciRepository;

        public BilanTechniqueExportDataManager(
            IAvancementManager avancementManager,
            IControleBudgetaireManager controleBudgetaireManager,
            IBudgetT4Manager budgetT4Manager,
            IReferentielEtenduManager referentielEtenduManager,
            IDepenseServiceMediator depenseServiceMediator,
            ICIRepository ciRepository)
        {
            this.avancementManager = avancementManager;
            this.controleBudgetaireManager = controleBudgetaireManager;
            this.budgetT4Manager = budgetT4Manager;
            this.referentielEtenduManager = referentielEtenduManager;
            this.depenseServiceMediator = depenseServiceMediator;
            this.ciRepository = ciRepository;
        }

        /// <summary>
        /// Retourne Les données du bilan technique
        /// </summary>
        /// <param name="model">Contient les filtres permettant de délimiter les données à exporter</param>
        /// <returns>Les sources à exporter, jamais null</returns>
        public async Task<BilanTechniqueExportModel> GetExportBilanDataAsync(LoadBilanTechniqueExportModel model)
        {
            int budgetId = controleBudgetaireManager.GetBudgetForCiAndPeriode(model.CiId, model.Periode)?.BudgetId ?? 0;
            List<BudgetDepenseModel> depensesCumulees = await GetDepensesAsync(model).ConfigureAwait(false);

            LoadBilanTechniqueExportModel modelMo = new LoadBilanTechniqueExportModel
            {
                CiId = model.CiId,
                IsPdfConverted = model.IsPdfConverted,
                Periode = model.Periode,
                RessourceId = GetChapitreId(model),
                RessourceType = RessourceType.Chapitre
            };

            List<BudgetDepenseModel> depensesCumuleesMo = await GetDepensesAsync(modelMo).ConfigureAwait(false);

            IEnumerable<AvancementEnt> avancementsCumule = avancementManager.GetAllAvancementCumuleForBudgetAndPeriode(budgetId, model.Periode);
            IEnumerable<AvancementEnt> avancementsPeriode = avancementManager.GetAllAvancementForBudgetAndPeriode(budgetId, model.Periode);
            int periodePrecedente = PeriodeHelper.GetPreviousPeriod(model.Periode).Value;
            IEnumerable<AvancementEnt> avancementsPeriodePrecedente = avancementManager.GetAllAvancementForBudgetAndPeriode(budgetId, periodePrecedente);

            BilanTechniqueExportModel dataToExport = GetMontantMo(model, budgetId, depensesCumuleesMo, avancementsCumule, avancementsPeriode, avancementsPeriodePrecedente);
            ICollection<BilanTechniqueExportBulkDataModel> exportBulkData = GetExportSourcesFromValeursBudgetees(model, budgetId, depensesCumulees, avancementsCumule, avancementsPeriode, avancementsPeriodePrecedente);
            ICollection<BilanTechniqueExportBulkDataModel> depensesNonBudgeteExportSources = GetExportSourcesFromDepensesNonBudgetees(model.Periode, depensesCumulees, exportBulkData);
            depensesNonBudgeteExportSources.ForEach(d => exportBulkData.Add(d));

            dataToExport.BulkData = exportBulkData;
            return dataToExport;
        }

        /// <summary>
        /// Créée un objet BilanTechniqueExportModel et rempli les propriétés concernant les montant budgétés, DadCumule...
        /// Cette fonction ne rempli pas la liste contenant le gros des données qui seront injectées dans l'excel
        /// </summary>
        /// <param name="model">Model décrivant le CiId et la période pour savoir quelles données récupérer</param>
        /// <param name="budgetId">Id du budget en application sur le CI</param>
        /// <param name="depensesCumulees">Toutes les dépenses cumulées sur ce CI</param>
        /// <param name="avancementsCumule">L'avancement cumulé jusqu'à la periode</param>
        /// <param name="avancementsPeriode">l'avancement de la période</param>
        /// <param name="avancementsPeriodePrecedente">l'avancement de la période précédente</param>
        /// <returns>Un objet de type BilanTechniqueExportModel, jamais null</returns>
        private BilanTechniqueExportModel GetMontantMo(LoadBilanTechniqueExportModel model, int budgetId, IEnumerable<BudgetDepenseModel> depensesCumulees, IEnumerable<AvancementEnt> avancementsCumule, IEnumerable<AvancementEnt> avancementsPeriode, IEnumerable<AvancementEnt> avancementsPeriodePrecedente)
        {
            BilanTechniqueExportModel exportModel = new BilanTechniqueExportModel();
            int chapitreId = GetChapitreId(model);

            IEnumerable<BudgetSousDetailEnt> allSdWithRessource = budgetT4Manager.GetByBudgetId(budgetId, loadSousDetails: true)
                    .SelectMany(b => b.BudgetSousDetails)
                    .Where(sd => sd.Ressource.SousChapitre.ChapitreId == chapitreId);

            IEnumerable<BudgetDepenseModel> depensesSurMo = depensesCumulees.Where(d => d.Ressource.SousChapitre.ChapitreId == chapitreId);

            IEnumerable<BudgetDepenseModel> depensesCourantesSurMo = depensesSurMo.Where(d => PeriodeHelper.IsDateTimeInPeriode(d.Periode, model.Periode));

            exportModel.MontantMoBudget = Convert.ToDouble(allSdWithRessource.Sum(sd => sd.Montant ?? 0));

            exportModel.MontantMoDadCumule = Convert.ToDouble(avancementsCumule.Where(a => allSdWithRessource.Any(sd => sd.BudgetSousDetailId == a.BudgetSousDetailId))
                                                                    .Sum(a => a.DAD));
            exportModel.MontantMoDepensesCumules = Convert.ToDouble(depensesSurMo.Sum(d => d.MontantHT));

            var montantDadPeriode = Convert.ToDouble(avancementsPeriode.Where(a => a.BudgetSousDetail.Ressource.SousChapitre.ChapitreId == chapitreId).Sum(a => a.DAD));
            var montantDadPeriodePrecedente = Convert.ToDouble(avancementsPeriodePrecedente.Where(a => a.BudgetSousDetail.Ressource.SousChapitre.ChapitreId == chapitreId).Sum(a => a.DAD));
            exportModel.MontantMoDadCourant = montantDadPeriode - montantDadPeriodePrecedente;

            exportModel.MontantMoDepensesCourantes = Convert.ToDouble(depensesCourantesSurMo.Sum(d => d.MontantHT));

            return exportModel;
        }

        private int GetChapitreId(LoadBilanTechniqueExportModel model)
        {
            int societeIdOfCi = ciRepository.SelectOneColumn(ci => ci.SocieteId, ci => ci.CiId == model.CiId).Single().Value;

            if (model.RessourceType.Equals(RessourceType.Chapitre))
            {
                return referentielEtenduManager.GetChapitresFromReferentielEtendus(societeIdOfCi)
                                                .Single(c => c.ChapitreId == model.RessourceId)
                                                .ChapitreId;
            }
            else if (model.RessourceType.Equals(RessourceType.SousChaptre))
            {
                return referentielEtenduManager.GetChapitresFromReferentielEtendus(societeIdOfCi)
                                                .Where(c => c.SousChapitres.Any(x => x.SousChapitreId == model.RessourceId))
                                                .Single().ChapitreId;
            }

            else
            {
                return referentielEtenduManager.GetChapitresFromReferentielEtendus(societeIdOfCi)
                                                .Where(c => c.SousChapitres.Any(r => r.Ressources.Any(x => x.RessourceId == model.RessourceId)))
                                                .Single().ChapitreId;
            }
        }

        /// <summary>
        /// Renvoie une liste de données a exporter en s'appuyant sur les valeurs non budgétées pour ce CI
        /// La fonction se base 
        /// </summary>
        /// <param name="periode">Periode jusqu'a laquelle les dépenses ont été récupérée</param>
        /// <param name="depensesCumulees">La liste de toutes les dépenses sur le CI et jusqu'a la période spécifiée dans model</param>
        /// <param name="exportSources">Les sources déjà remplies avec les dépenses budgétées</param>
        /// <returns>Une IEnumerable, potentiellement vide, jamais null</returns>
        private ICollection<BilanTechniqueExportBulkDataModel> GetExportSourcesFromDepensesNonBudgetees(int periode, IEnumerable<BudgetDepenseModel> depensesCumulees, IEnumerable<BilanTechniqueExportBulkDataModel> exportSources)
        {
            List<BilanTechniqueExportBulkDataModel> depensesNonBudgeteExportSources = new List<BilanTechniqueExportBulkDataModel>();
            IEnumerable<BudgetDepenseModel> depensesNonBudgetees = depensesCumulees.Where(d => !exportSources.Any(es => es.T3Code == d.Tache.Code));
            foreach (IGrouping<int, BudgetDepenseModel> depensesSameT3 in depensesNonBudgetees.GroupBy(d => d.TacheId))
            {
                decimal? sumQuantiteDepense = depensesSameT3.Sum(d => d.Quantite);
                IEnumerable<BudgetDepenseModel> depensesMoisCourant = depensesSameT3.Where(d => PeriodeHelper.IsDateTimeInPeriode(d.Periode, periode));
                decimal? sumQuantiteDepensesMoisCourant = depensesMoisCourant.Sum(d => d.Quantite);

                bool allSameUnite = depensesSameT3.All(d => d.UniteId == depensesSameT3.First().UniteId);

                depensesNonBudgeteExportSources.Add(new BilanTechniqueExportBulkDataModel
                {
                    T3Code = depensesSameT3.First().Tache.Code,
                    LibelleT3 = depensesSameT3.First().Tache.Libelle,
                    RessourceUniteCode = allSameUnite ? depensesSameT3.First().Unite.Code : "#",
                    QuantiteBudget = 0,
                    QuantiteAvancementCumule = 0,
                    QuantiteAvancementCourant = 0,
                    QuantiteDepensesCourant = Convert.ToDouble(sumQuantiteDepensesMoisCourant),
                    QuantiteDepensesCumulee = Convert.ToDouble(sumQuantiteDepense)
                });
            }

            return depensesNonBudgeteExportSources;
        }

        /// <summary>
        /// Renvoie une liste de données a exporter en s'appuyant sur les valeurs budgétées pour ce CI
        /// </summary>
        /// <param name="model">Variable permettant de délimiter les valeurs à récupérer (sur quel ci, quel budget)</param>
        /// <param name="budgetId">Id du budget en application</param>
        /// <param name="depensesCumulees">Liste des dépenses sur le CI décrit dans le model</param>
        /// <param name="avancementsCumule">L'avancement cumulé jusqu'à la période tel que spécifiée dans Model</param>
        /// <param name="avancementsPeriode">L'avancement sur la période tel que spécifiée dans Model</param>
        /// <param name="avancementsPeriodePrecedente">L'avancement sur la période pécédente a celle spécifiée dans Model</param>
        /// <returns>une liste jamais null mais potentiellement vide</returns>
        private ICollection<BilanTechniqueExportBulkDataModel> GetExportSourcesFromValeursBudgetees(LoadBilanTechniqueExportModel model, int budgetId, IEnumerable<BudgetDepenseModel> depensesCumulees, IEnumerable<AvancementEnt> avancementsCumule, IEnumerable<AvancementEnt> avancementsPeriode, IEnumerable<AvancementEnt> avancementsPeriodePrecedente)
        {
            IEnumerable<BudgetSousDetailEnt> sousDetailToExport = GetRessourceFilterFromModel(model, budgetId);
            IEnumerable<IGrouping<int?, BudgetSousDetailEnt>> sdGrouppedByT3 = sousDetailToExport.GroupBy(sd => sd.BudgetT4.T3Id);

            List<BilanTechniqueExportBulkDataModel> exportSources = new List<BilanTechniqueExportBulkDataModel>();

            foreach (IGrouping<int?, BudgetSousDetailEnt> grouppedSd in sdGrouppedByT3)
            {
                var avancementsCumuleSousDetail = avancementsCumule.Where(a => grouppedSd.Any(sd => sd.BudgetSousDetailId == a.BudgetSousDetailId));
                var avancementsPeriodeSousDetail = avancementsPeriode.Where(a => grouppedSd.Any(sd => sd.BudgetSousDetailId == a.BudgetSousDetailId));
                var avancementsPeriodePrecedenteSousDetail = avancementsPeriodePrecedente.Where(a => grouppedSd.Any(sd => sd.BudgetSousDetailId == a.BudgetSousDetailId));

                IEnumerable<BudgetDepenseModel> allDepensesSurT3 = depensesCumulees.Where(d => d.TacheId == grouppedSd.Key.Value);
                IEnumerable<BudgetDepenseModel> allDepensesMoisCourant = allDepensesSurT3.Where(d => PeriodeHelper.IsDateTimeInPeriode(d.Periode, model.Periode));

                decimal? quantiteDepensesSurT3 = allDepensesSurT3.Sum(d => d.Quantite);
                decimal? quantiteDepensesMoisCourant = allDepensesMoisCourant.Sum(d => d.Quantite);

                decimal quantiteAvancementCumule = (avancementsCumuleSousDetail?.Sum(a => a.PourcentageSousDetailAvance * a.BudgetSousDetail.Quantite) / 100) ?? 0;
                decimal quantiteAvancementCourant = ((avancementsPeriodeSousDetail?.Sum(a => a.PourcentageSousDetailAvance * a.BudgetSousDetail.Quantite) / 100) ?? 0)
                                                  - ((avancementsPeriodePrecedenteSousDetail?.Sum(a => a.PourcentageSousDetailAvance * a.BudgetSousDetail.Quantite) / 100) ?? 0);
                decimal quantiteBudget = grouppedSd.Sum(sd => sd.Quantite ?? 0);

                bool allSameUniteAndNotNull = grouppedSd.All(sd => sd.UniteId == grouppedSd.First().UniteId && sd.UniteId != null);

                exportSources.Add(new BilanTechniqueExportBulkDataModel
                {
                    T3Code = grouppedSd.First().BudgetT4.T3.Code,
                    LibelleT3 = grouppedSd.First().BudgetT4.T3.Libelle,
                    RessourceUniteCode = allSameUniteAndNotNull ? grouppedSd.First().Unite.Code : "#",
                    QuantiteBudget = Convert.ToDouble(quantiteBudget),
                    QuantiteAvancementCumule = Convert.ToDouble(quantiteAvancementCumule),
                    QuantiteAvancementCourant = Convert.ToDouble(quantiteAvancementCourant),
                    QuantiteDepensesCourant = Convert.ToDouble(quantiteDepensesMoisCourant),
                    QuantiteDepensesCumulee = Convert.ToDouble(quantiteDepensesSurT3)
                });
            }

            return exportSources;
        }

        private IEnumerable<BudgetSousDetailEnt> GetRessourceFilterFromModel(LoadBilanTechniqueExportModel model, int budgetId)
        {
            Func<BudgetSousDetailEnt, bool> whereRessourceFunc;
            switch (model.RessourceType)
            {
                case RessourceType.Chapitre:
                    whereRessourceFunc = sd => sd.Ressource.SousChapitre.ChapitreId == model.RessourceId;
                    break;
                case RessourceType.SousChaptre:
                    whereRessourceFunc = sd => sd.Ressource.SousChapitreId == model.RessourceId;
                    break;
                case RessourceType.Ressource:
                    whereRessourceFunc = sd => sd.RessourceId == model.RessourceId;
                    break;
                default:
                    throw new FredBusinessException("Type de ressource non supporté !");
            }

            return budgetT4Manager.GetByBudgetId(budgetId, loadSousDetails: true)
                                .SelectMany(b => b.BudgetSousDetails)
                                .Where(whereRessourceFunc);
        }

        private async Task<List<BudgetDepenseModel>> GetDepensesAsync(LoadBilanTechniqueExportModel model)
        {
            DateTime dtPeriode = PeriodeHelper.ToLastDayOfMonthDateTime(model.Periode).Value;
            var filtre = new SearchDepense
            {
                CiId = model.CiId,
                PeriodeDebut = null,
                PeriodeFin = dtPeriode
            };

            Func<BudgetDepenseModel, bool> whereRessourceFunc;
            switch (model.RessourceType)
            {
                case RessourceType.Chapitre:
                    whereRessourceFunc = d => d.Ressource.SousChapitre.ChapitreId == model.RessourceId;
                    break;
                case RessourceType.SousChaptre:
                    whereRessourceFunc = d => d.Ressource.SousChapitreId == model.RessourceId;
                    break;
                case RessourceType.Ressource:
                    whereRessourceFunc = d => d.RessourceId == model.RessourceId;
                    break;
                default:
                    throw new FredBusinessException("Type de ressource non supporté !");
            }

            // Le ToList est indispensable ici pour avoir de bonne performance
            // Sans celui-ci, le mapper sera appelé à chaque énumération
            return BudgetDepenseMapper.Map(await depenseServiceMediator.GetAllDepenseExternetWithTacheAndRessourceAsync(filtre).ConfigureAwait(false)).Where(whereRessourceFunc).ToList();
        }
    }
}
